-- Copyright (c) 2023, Geoffrey M. Poore
-- All rights reserved.
--
-- Licensed under the BSD 3-Clause License:
-- http://opensource.org/licenses/BSD-3-Clause
--


-- Library for manipulating `sourcepos` data generated by Pandoc, and for
-- generating `sourcepos` data for formats that lack Pandoc `sourcepos`
-- support.
--
--
-- # Preprocessing filters for Pandoc-generated `sourcepos` data
--
-- The `sourceposlib.strMergeFilter` merges adjacent `Str` nodes that are
-- wrapped in `sourcepos` spans into a single `Str` node in a single
-- `sourcepos` span, so that the final `Str` node has the same content as
-- would be generated without `sourcepos`.  It makes `sourcepos` more
-- compatible with filters operating on `Str` nodes.
--
-- The `sourceposlib.stripSourceposFilter` removes all `sourcepos` data.  It
-- is intended for parts of a document where `sourcepos` data is not needed
-- and should be removed to simplify the AST for subsequent filters.
--
--
-- # Generating `sourcepos` data
--
-- The `sourceposlib.addSourcepos()` function adds `sourcepos` data to an AST.
-- It walks through the AST, and for each
-- Str/Code/CodeBlock/RawInline/RawBlock node it searches the document sources
-- for the corresponding text.  Each search picks up where the last successful
-- search ended.  Each successful search results in the current search node
-- being wrapped in a Span/Div node containing source data in the `sourcepos`
-- format:  `data-pos` attribute with source info.  The `sourcepos` data
-- differs from that provided by Pandoc in a few ways.
--
--   * Source names are omitted.  All line numbers refer to line numbers in
--     the concatenated sources, rather than line numbers within individual
--     sources.  This provides a simple, unambiguous way to handle sources
--     that are included multiple times.  It does mean that external
--     applications using the `sourcepos` data must maintain a mapping between
--     line numbers in the concatenated sources and line numbers in individual
--     sources.
--
--   * Only line numbers are calculated.  Column numbers are always set to 0
--     (zero).  Column numbers cannot be determined accurately unless they are
--     tracked during document parsing.  Line numbers themselves will not
--     always be correct, since they are reconstructed after parsing.
--
--   * `sourcepos` data is not guaranteed.  If the parallel search between the
--     AST and the sources fails to find matches for part of a document, no
--     `sourcepos` data is added to the AST for that region.
--
-- The generated `sourcepos` data has limitations compared to Pandoc
-- `sourcepos` support.
--
--   * Attempting to generate `sourcepos` data after parsing will always be
--     less accurate.
--
--   * `sourcepos` data is only generated for code points in the Basic
--     Multilingual Plane (BMP).  Punctuation and symbol code points are also
--     ignored.
--
--   * Tables with multi-line cells can interfere with the current algorithm.
--     The current algorithm proceeds topdown through the AST and linearly
--     through the sources.  However, multi-line table cells span multiple
--     source lines, which would require backtracking in the sources.  In many
--     cases, the `sourcepos` algorithm will automatically recover.  However,
--     it will fail for "long" multi-line cells, and it can become inaccurate
--     when adjacent cells contain similar or identical text.
--
--   * Footnotes that are not defined inline can introduce inaccuracies.  The
--     current algorithm proceeds topdown through the AST and linearly through
--     the sources.  When footnotes are not defined inline, backtracking or
--     lookahead would be required to generate precise `sourcepos` data.  In
--     many cases, the `sourcepos` algorithm will automatically recover.
--     However, it will fail for "very long" footnotes, and it can become
--     inaccurate for shorter footnotes.
--


local VERSION = {0, 1, 0}
local VERSION_DATE = '20230324'
local VERSION_STRING = table.concat(VERSION, '.')
local AUTHOR_NOTE = table.concat({
    'Library for manipulating sourcepos data generated by Pandoc, and for generating sourcepos data for formats that lack Pandoc sourcepos support.',
    'Version ' .. VERSION_STRING .. ' from ' .. VERSION_DATE .. '.',
    'Copyright (c) 2023, Geoffrey M. Poore.',
    'All rights reserved.',
    'Licensed under the BSD 3-Clause License: http://opensource.org/licenses/BSD-3-Clause.',
}, '\n')
local sourceposlib = {
    VERSION        = VERSION,
    VERSION_DATE   = VERSION_DATE,
    VERSION_STRING = VERSION_STRING,
    AUTHOR_NOTE    = AUTHOR_NOTE,
}




-- Pandoc Lua filter for preprocessing an AST with `sourcepos` data.  Intended
-- to run before all other filters.  Merges adjacent `Str` nodes that are
-- wrapped in `sourcepos` spans, so that the final `Str` nodes have the same
-- content as would be generated without `sourcepos`.  With `sourcepos`, some
-- adjacent non-whitespace characters are split into multiple `Str` nodes, and
-- then each of these is wrapped in a `sourcepos` span.
sourceposlib.strMergeFilter = {
    Inlines = function (nodes)
        local didModify = false
        local preprocNodes = pandoc.Inlines{}
        local lastStrNode = nil
        for _, node in pairs(nodes) do
            if node.t == 'Span' and node.attributes['data-pos'] ~= nil and #node.c == 1 and node.c[1].t == 'Str' then
                if lastStrNode ~= nil then
                    -- There is no attempt to merge the `data-pos` attributes
                    -- here, because only the line numbers are used for scroll
                    -- sync.  Adjacent string nodes are always on the same
                    -- line, and inaccurate column numbers are irrelevant.
                    lastStrNode.text = lastStrNode.text .. node.c[1].text
                    didModify = true
                else
                    lastStrNode = node.c[1]
                    preprocNodes:insert(node)
                end
            else
                lastStrNode = nil
                preprocNodes:insert(node)
            end
        end
        if didModify then
            return preprocNodes
        end
        return nil
    end
}

-- Remove all `sourcepos` data.
local stripSourcepos = function (node)
    local dataPos = node.attributes['data-pos']
    if dataPos == nil then
        return nil
    end
    if node.identifier == '' and #(node.classes) == 0 and #(node.attributes) == 1 then
        return node.content
    end
    node.attributes['data-pos'] = nil
    return node
end
sourceposlib.stripSourceposFilter = {
    Span = stripSourcepos,
    Div = stripSourcepos,
}




-- Pattern for matching punctuation, symbols, and similar code points that may
-- appear in the AST differently than in the source.
--
-- ASCII punctuation and symbols will often be backslash-escaped or otherwise
-- escaped in the document source, since formats like Markdown give them
-- special roles.  So a literal ASCII punctuation/symbol character in the AST
-- will often correspond to an escaped version in the source.  The Pandoc
-- `smart` extension converts straight ASCII quotation marks into curly
-- quotation marks, hyphen sequences into dashes, three periods into an
-- ellipsis symbol, and some spaces into non-breaking spaces.  So curly
-- quotation marks, dashes, ellipsis symbols, and non-breaking spaces in the
-- AST will often correspond to different code points/sequences in the source.
-- Under some circumstances raw HTML in the AST has different spacing than the
-- original source, so spaces should be ignored.  Finally, symbols and
-- punctuation beyond the ASCII range will often be generated through some
-- sort of escape or macro in the document source.
--
-- References:
--   * LPeg.re docs:  http://www.inf.puc-rio.br/~roberto/lpeg/re.html
--   * Pandoc smart extension:  https://pandoc.org/MANUAL.html#extension-smart
--   * AST raw HTML spacing:  https://github.com/jgm/pandoc/issues/5305
local SKIPPED_CODEPOINT_RANGES = {
    -- Basic Latin:  Control, symbols, punctuation (that is, non-alphanumeric)
    -- Note Lua escape of magic character `%\x5B` -> `%[`
    '[\x00-\x2F] / [\x3A-\x40] / [%\x5B-\x60] / [\x7B-\x7F]',
    -- Latin-1 Supplement:  Control, symbols, punctuation
    '[\xC2][\x80-\xBF] / [\xC3][\x97\xB7]',
    -- General Punctuation through Miscellaneous Symbols and Arrows
    '[\xE2][\x80-\xAF][\x80-\xBF]',
    -- Above BMP
    '[\xF0-\xF4][\x90-\x8F][\x80-\xBF][\x80-\xBF]',
}
local SKIPPED_CODEPOINT_PATTERN = '(' .. table.concat(SKIPPED_CODEPOINT_RANGES, ' / ') .. ')+'

-- Functions for skipping over initial parts of a document, such as metadata
-- or a preamble
local skipInitial = {
    latex = function (doc, text, pandocExtensions, customExtensions)
        local _, endIndex = text:find('^[ \t]*\\begin{document} *\n')
        if endIndex ~= nil and text:sub(1, endIndex):match('\\documentclass[%[{]') then
            return endIndex + 1
        end
        return nil
    end,
    markdown = function (doc, text, pandocExtensions, customExtensions)
        if not pandocExtensions['yaml_metadata_block'] then
            return nil
        end
        local hasMeta = false
        for _, _ in pairs(doc.meta) do
            hasMeta = true
            break
        end
        if not hasMeta then
            return nil
        end
        if text:sub(1, 3) ~= '---' then
            return nil
        end
        local _, endIndex = text:find('^%-%-%- *\n[%w_].-\n%-%-%- *\n')
        if endIndex == nil then
            _, endIndex = text:find('^%-%-%- *\n[%w_].-\n%.%.%. *\n')
        end
        if endIndex ~= nil then
            return endIndex + 1
        end
        return nil
    end,
}
for _, fmt in pairs({'markdown_mmd', 'markdown_phpextra', 'markdown_strict'}) do
    skipInitial[fmt] = skipInitial.markdown
end


sourceposlib.searchDistanceDefault = 80
sourceposlib.searchDistanceIncrement = 40
sourceposlib.searchDistanceMax = sourceposlib.searchDistanceDefault * 10

-- addSourcepos(
--   doc: <Pandoc AST>,
--   text: <concatenated text from all sources used to generate AST>,
--   format: <format name, without extensions (without `+-extension`)>,
--   pandocExtensions: <table<str, bool> of extensions supported by Pandoc>,
--   customExtensions: <table<str, bool> of custom extensions>,
--   offset: <line number offset for AST that is part of a larger document>,
-- )
sourceposlib.addSourcepos = function (doc, text, format, pandocExtensions, customExtensions, offset)
    local searchDistanceDefault = sourceposlib.searchDistanceDefault
    local searchDistanceIncrement = sourceposlib.searchDistanceIncrement
    local searchDistanceMax = sourceposlib.searchDistanceMax
    local searchDistance = searchDistanceDefault
    local lineNumber = 1
    local textIndex = 1
    -- Skip over initial parts of a document, such as metadata or a preamble
    if skipInitial[format] ~= nil then
        textIndex = skipInitial[format](doc, text, pandocExtensions, customExtensions) or 1
        if textIndex > 1 then
            local stringbyte = string.byte
            local newlineAsByte = stringbyte('\n')
            for index = 1, textIndex - 1 do
                if stringbyte(text, index) == newlineAsByte then
                    lineNumber = lineNumber + 1
                end
            end
        end
    end
    -- Actual searches are performed in a small moving "window" of text that
    -- is a few multiples of the max search distance in length.  This prevents
    -- failed searches from always going to the end of the source text.  It
    -- also reduces direct usage of the full source text.  Both help
    -- performance for longer sources.
    local subtextDefaultSize = searchDistanceDefault * 10
    local subtextIndex = 1
    local subtext = text:sub(textIndex, textIndex + subtextDefaultSize - 1)

    local findNode = function (node)
        -- In checking the `subtext` size, `subtextIndex` and `searchDistance`
        -- overlap by 1, and `searchDistance` and `node.text` must overlap
        -- by at least 1.  Hence the `- 2`.
        if subtextIndex + searchDistance + node.text:len() - 2 > subtext:len() then
            textIndex = textIndex + subtextIndex - 1
            -- Allow `subtext` to be larger than `subtextDefaultSize`
            -- to handle long runs of skipped code points
            if searchDistance + node.text:len() - 1 <= subtextDefaultSize then
                subtext = text:sub(textIndex, textIndex + subtextDefaultSize - 1)
            else
                subtext = text:sub(textIndex, textIndex + searchDistance + node.text:len() - 2)
            end
            subtextIndex = 1
        end
        local skippedStartIndex, skippedEndIndex = re.find(node.text, SKIPPED_CODEPOINT_PATTERN)
        local lastSkippedEndIndex
        local searchString
        if skippedStartIndex == nil then
            searchString = node.text
        elseif skippedStartIndex == 1 then
            if skippedEndIndex == node.text:len() then
                searchDistance = math.min(searchDistance + node.text:len() + searchDistanceIncrement, searchDistanceMax)
                return nil, nil
            end
            lastSkippedEndIndex = skippedEndIndex
            skippedStartIndex, skippedEndIndex = re.find(node.text, SKIPPED_CODEPOINT_PATTERN, lastSkippedEndIndex + 1)
            if skippedStartIndex == nil then
                searchString = node.text:sub(lastSkippedEndIndex + 1)
            else
                searchString = node.text:sub(lastSkippedEndIndex + 1, skippedStartIndex - 1)
            end
        else
            searchString = node.text:sub(1, skippedStartIndex - 1)
        end
        local lastSubtextIndex = subtextIndex
        local subtextFindStartIndex, subtextFindEndIndex = subtext:find(searchString, subtextIndex, true)
        local firstSubtextFindStartIndex
        local lastSubtextFindEndIndex
        if subtextFindStartIndex ~= nil and subtextFindStartIndex < subtextIndex + searchDistance then
            subtextIndex = subtextFindEndIndex + 1
            firstSubtextFindStartIndex = subtextFindStartIndex
            lastSubtextFindEndIndex = subtextFindEndIndex
        end
        while skippedEndIndex ~= nil and skippedEndIndex < node.text:len() do
            lastSkippedEndIndex = skippedEndIndex
            skippedStartIndex, skippedEndIndex = re.find(node.text, SKIPPED_CODEPOINT_PATTERN, lastSkippedEndIndex + 1)
            if skippedStartIndex == nil then
                searchString = node.text:sub(lastSkippedEndIndex + 1)
            else
                searchString = node.text:sub(lastSkippedEndIndex + 1, skippedStartIndex - 1)
            end
            subtextFindStartIndex, subtextFindEndIndex = subtext:find(searchString, subtextIndex, true)
            if subtextFindStartIndex ~= nil and subtextFindStartIndex < subtextIndex + searchDistance then
                subtextIndex = subtextFindEndIndex + 1
                if firstSubtextFindStartIndex == nil then
                    firstSubtextFindStartIndex = subtextFindStartIndex
                end
                lastSubtextFindEndIndex = subtextFindEndIndex
            end
        end
        if firstSubtextFindStartIndex == nil then
            searchDistance = math.min(searchDistance + node.text:len() + searchDistanceIncrement, searchDistanceMax)
            return nil, nil
        end
        local stringbyte = string.byte
        local newlineAsByte = stringbyte('\n')
        for index = lastSubtextIndex, firstSubtextFindStartIndex - 1 do
            if stringbyte(subtext, index) == newlineAsByte then
                lineNumber = lineNumber + 1
            end
        end
        local startLineNumber = lineNumber
        for index = firstSubtextFindStartIndex, lastSubtextFindEndIndex do
            if stringbyte(subtext, index) == newlineAsByte then
                lineNumber = lineNumber + 1
            end
        end
        searchDistance = searchDistanceDefault
        return startLineNumber, lineNumber
    end
    local sourceposInline = function (node)
        local startLineNumber, endLineNumber = findNode(node)
        if startLineNumber == nil then
            return nil
        end
        -- Column numbers are not calculated, since scroll sync only uses line
        -- numbers.  Column numbers would often be slightly inaccurate anyway,
        -- due to skipped code points.
        local dataPos = tostring(startLineNumber + offset) .. ':0-' .. tostring(endLineNumber + offset) .. ':0'
        -- Return `false` as second value to prevent walking through new node
        return pandoc.Span(node, pandoc.Attr("", {}, {{'data-pos', dataPos}})), false
    end
    local sourceposBlock = function (node)
        local startLineNumber, endLineNumber = findNode(node)
        if startLineNumber == nil then
            return nil
        end
        -- Column numbers are not calculated, since scroll sync only uses line
        -- numbers.  Column numbers would often be slightly inaccurate anyway,
        -- due to skipped code points.
        local dataPos = tostring(startLineNumber + offset) .. ':0-' .. tostring(endLineNumber + offset) .. ':0'
        -- Return `false` as second value to prevent walking through new node
        return pandoc.Div(node, pandoc.Attr("", {}, {{'data-pos', dataPos}})), false
    end

    -- Don't search through footnotes, since many formats allow the footnote
    -- text to be defined in a different location than the footnote reference.
    -- But do increase the search distance to allow for inline footnote
    -- definitions.
    local footnoteLength
    local footnoteLengthCounter = function (node)
        footnoteLength = footnoteLength + node.text:len()
        return nil
    end
    local footnoteLengthFilter = {
        Str = footnoteLengthCounter,
        Code = footnoteLengthCounter,
        RawInline = footnoteLengthCounter,
        CodeBlock = footnoteLengthCounter,
        RawBlock = footnoteLengthCounter,
    }
    local sourceposNote = function (node)
        footnoteLength = 0
        node:walk(footnoteLengthFilter)
        -- Increase search distance to help jump over inline footnote
        -- definitions with minimal missed/incorrect searches.
        -- `searchDistance` is reset to default value at the next successful
        -- search, so this won't help with footnotes defined in a separate
        -- block elsewhere.  Use `2*footnoteLength` to account for markup.
        searchDistance = math.min(searchDistance + 2*footnoteLength, searchDistanceMax)
        return nil, false
    end
    doc.blocks = doc.blocks:walk({
        traverse = 'topdown',
        Str = sourceposInline,
        Code = sourceposInline,
        RawInline = sourceposInline,
        CodeBlock = sourceposBlock,
        RawBlock = sourceposBlock,
        Note = sourceposNote,
    })

    -- Get `sourcepos` data for images based on the Str/Code/RawInline nodes
    -- they contain.  Image location data is valuable for scroll sync purposes
    -- since images have variable dimensions.
    local startImageDataPos, endImageDataPos
    local imageFilter = {
        traverse = 'topdown',
        Span = function (node)
            local dataPos = node.attributes['data-pos']
            if dataPos == nil then
                return nil
            end
            local startNodeDataPos, endNodeDataPos = dataPos:match('^(%d+:%d)-(%d+:%d)$')
            if startImageDataPos == nil then
                startImageDataPos = startNodeDataPos
            end
            endImageDataPos = endNodeDataPos
            return nil
        end
    }
    local sourceposImage = function (node)
        startImageDataPos = nil
        endImageDataPos = nil
        node:walk(imageFilter)
        if startImageDataPos == nil then
            return nil
        end
        node.attributes['data-pos'] = startImageDataPos .. '-' .. endImageDataPos
        return node
    end
    doc.blocks = doc.blocks:walk({
        Image = sourceposImage,
    })

    return doc
end

return sourceposlib
